Trabalho elaborado por

Raimundo de Araujo Pereira Santos,
no. usp 678345-7


Anotações sobre o trabalho do terceiro laboratório de Estrutura de
Dados:

Lista Estática Sequencial

1o: concluir o esboço da implementação apresentado em aula
    Feito!

2o: alterar as funções de remoção (tanto em C quanto em C++) para que
    retornem o elemento removido e não verdadeiro ou falso. 

    Feito, com ressalvas: a implementação dessa funcionalidade deve ser
    repensada, pois é pedido que o retorno seja do elemento e não de um
    ponteiro para o elemento. Seria melhor retornar um ponteiro pela
    possibilidade de retornar NULL e mostrar se falhou para o cliente da
    lista. Tal situação foi demonstrada no código de imp_2/main.c .

    O inconveniente do retorno por ponteiro é ter que deixar a
    desalocação por conta do usuário da lista. Para contornar isso,
    poder-se-ia continuar a retornar um booleano, mas passar outro
    parâmetro, que é um ponteiro para colocar dentro o elemento a ser
    removido. Seria mais interessante assim, pois o cliente fica
    responsável por criar e remover um ponteiro.

    Outra possível solução seria marcar um dos campos do elemento com
    algo que indicasse o erro. Mas essa solução tornaria a lista
    excludente para guardar elementos que contivessem por natureza essa
    marca.

    O g++ não me permitiu retornar com 'return;' simples, sem algum
    valor, como fiz no C. Assim, tive que deixar chave = 0 e *info =
    '\0' pra não sucesso.

3o: fazer com que seja uma Lista Ordenada pelo critério da ordem
    alfabética.

    Alterar as funções de inserção e remoção de elementos para que
    cuidem de sempre ter a lista em ordem alfabética. Se ao começar a
    inserir elementos já tiver esse cuidado, então será simples manter
    em ordem.

    Apesar de ainda existir a chave, a ordenação pelo alfabeto será a
    chave da ordenação, portanto a função igual() deve retornar o que
    especifica a qsort() do C, para eu não ter que implementar a
    ordenação em si. Segundo a documentação da qsort, a função de
    comparação deve retornar negativo, zero ou estritamente positivo nos
    respectivos casos: quando o primeiro argumento passado for menor,
    igual ou maior que o segundo.

    O usuário já não pode mais decidir exatamente onde inserir o
    elemento, portanto a função Inserir não recebe mais o argumento da
    posição.

    Por simplicidade - ou seja, para não incorrer em erros na hora de
    escrever código - usei qsort() em C++ também, o que me levou a
    escrever uma função wrapper para poder passá-la a qsort(), pois
    existe uma complexidade absurda inerente a utilização de ponteiros
    para funções membro, cujo entendimento foje ao escopo deste
    trabalho.

Diversos comentários foram feitos nos códigos, que estão organizados em
subdiretórios deste em que está este arquivo. São eles:

imp_1/ - implementação da 1a parte
imp_2/ - implementação da 2a parte
imp_3/ - implementação da 3a parte

Os arquivos dentro desses diretórios se dividem assim:

*.c, *.h -> implementação em C
*.cpp, *.hpp -> implementação em C++


