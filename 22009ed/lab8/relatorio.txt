Trabalho elaborado por

Raimundo de Araujo Pereira Santos,
no. usp 678345-7

Implementação de Árvore Binária

Implementação de uma árvore binária comum, nem de busca, nem própria ou
estrita.

Funções a serem implementadas:

int size(Tree* T);
bool isEmpty(Tree* T);
node* root(Tree* T);
node* parent(node* c);
bool isInternal(node* c);
bool isExternal(node* c);
bool isRoot(node* c);
node* leftChild(Tree* T, node* c);
node* rightChild(Tree* T, node* c);
node* sibiling(Tree* T, node* c);
void swap(Tree* T, node* c, node* d);
void replace(Tree* T, node* c, tipo_elem e);
node* remove(Tree* T, node* c);
node* insertLeft(Tree* T, node* parent, tipo_elem ele);
node* insertRight(Tree* T, node* parent, tipo_elem ele);
node* search(Tree* T, node* c, tipo_elem c);
node* expandExternal(Tree* T, node* v);
node* removeAboveExternal(Tree* T, node* v);

Pela primeira vez, usando efetivamente templates em C++. Tanto para a
classe BTNode (Binary Tree Node) quanto paara a classe BinTree em si,
pois posso colocar o tipo de elemento que eu quiser, desde que algumas
operações estejam definidas: as de comparação e a de atribuição ( <, >,
<=, >=, ==, != e =).

size(): duas formas de fazer isso. A primeira é a cada nó inserido ou
removido, adicionar ou subtrair uma unidade de 'size', respectivamente.
A segunda é uma forma recursiva: toda vez que a função é chamada, ela
percorre toda a árvore, contando os nós. A primeira é mais rápida, pois
o valor sempre estará ali, a postos, para consulta, a seungda é mais
segura, pois sempre conta a quantidade de nós. Como quem controla a
insersação é a remoção, em C++, é a classe BinTree, então posso
assegurar, com a primeira forma, que sempre será correto o valor em
'size'. Se a implementação que eu escolhi fosse C, preferiria o método
recursivo, já que, por algum erro, alguma função pode alterar o valor em
'size'. Resolvi implementar os dois métodos, diferenciando-os pelo
argumento: a primeira forma não recebe argumentos, a segunda
obrigatoriamente recebe o nó-raiz da árvore em questão.

O tipo_elem, aqui representado pela classe Elem, tem os operadores de
comparação, os relacionais. Mas eles agem conforme a chave numérica, por
enquanto. Isso deve ser mudado quando o que for mais importante for a
ordem alfabética.

Bem, parece que por causa dessa minha gana em usar templates, preciso
colocar todo o código dentro do header ao invés de separar. Que chato.
Bom, pelo menos foi a solução para linkar, já que da outra forma não
entendi como funciona - se é que existe como funcionar.



