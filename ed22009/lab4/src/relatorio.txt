Trabalho elaborado por

Raimundo de Araujo Pereira Santos,
no. usp 678345-7


Anotações sobre o trabalho do quarto laboratório de Estrutura de
Dados:

Neste laboratório o principal era criar as listas dinâmicas simples e
duplamente ligadas. Fiz isso implementando e testando-as na seguinte
estrutura de diretórios:

lista_base/
	
	elem.h -> a definição da classe dos elementos da lista
	elem.cpp -> a implementacção da classe dos elementos da lista
	lista_base.h -> a definição da classe que dá base para os tipos
	de lista

lista_simples/
	
	lista_simples.h -> definição de lista simplesmente encadeada
	lista_simples.cpp -> implementação da classe de lista simp.

lista_dupla/
	
	lista_dupla.h -> definição da lista duplamente encadeada
	lista_dupla.cpp -> implementação da classe de lista dupla.

main_ldupla.cpp -> programa de teste para lista dupla.
main_lsimples.cpp -> programa de teste para lista simples.
Makefile -> controle de compilação simplificado

Mas como o objetivo do professor é ter um único header com a
funcionalidade de lista e esconder do usuário qual o tipo de
implementação, então vou colocar tudo no mesmo .h e usar polimorfismo.
No fim das contas acabo não escondendo do mesmo jeito, pois obrigo o
usuário da minha classe a instanciar objetos das classes específicas.

Uma forma seria dar ao usuário um objeto já criado para usar, mas isso é
estranho demais, limitador demais.

Com a definição das classes todas no mesmo arquivo, separei somente as
implementações de cada método, junto com a implementação de cada
classe-nó. Como em C++ as classes definem os tipos de lista e a cada
tipo pertencem métodos distintos - mesmo que sejam identicos os nomes -
então posso linkar o executável final contra cada um dos tipos que eu
criar, ou seja, posso fazer o benchmark através do mesmo programa.

Não foi como eu esperava, pois me esqueci que a classe Nodo é usada
pelos diversos tipos de listas, e tudo nessa classe tem o mesmo nome em
cada arquivo de implementação. Assim sendo, terei de criar uma classe
pai e fazer polimorfismo aqui também.

Outro problema enfrentado foi com o código para calcular o tempo
transcorrido de processamento. O código passado pelo professor não se
mostrou robusto o suficiente, diversos alunos tiveram problemas para
implementá-lo. Não era um código robusto, de sorte que o seguinte trecho
funciona melhor e com garantia dentro de um sistema unix-like:

#include <sys/time.h>

....

struct timeval start, end;
gettimeofday(&start, NULL);

/* codigo a ter o tempo medido */

gettimeofday(&end, NULL);

double elapsed = (end.tv_usec - start.tv_usec) / 1000000.0;

Assim, temos elapsed em segundos. Adotei este código para meu benchmark,
o que torna meu código preso ao unix. Talvez o Cygwin compile esse
código sem problemas, mas não tive como testar ainda.


